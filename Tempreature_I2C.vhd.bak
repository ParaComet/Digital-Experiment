library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Temperature_I2C is
  generic (
    INPUT_CLK : integer := 1_000_000;
    I2C_CLK   : integer := 100_000
  );
  port (
    clk       : in  std_logic;
    rst       : in  std_logic;
    ena       : in  std_logic;
    addr      : in  std_logic_vector(6 downto 0);
    rw        : in  std_logic;
    data_wr   : in  std_logic_vector(7 downto 0);
    data_rd   : out std_logic_vector(7 downto 0);
    busy      : out std_logic;
    ack_error : out std_logic;
    scl       : out std_logic;
    sda       : inout std_logic;
    byte_valid: out std_logic
  );
end entity;

architecture rtl of Temperature_I2C is

  constant HALF_TICKS : integer := INPUT_CLK / (2 * I2C_CLK);

  signal scl_reg    : std_logic := '1';
  signal sda_reg    : std_logic := '1';
  signal sda_dir    : std_logic := '1';
  signal scl_enable : std_logic := '0';

  signal data_rd_r  : std_logic_vector(7 downto 0) := (others => '0');
  signal busy_r     : std_logic := '0';
  signal ack_err_r  : std_logic := '0';
  signal byte_valid_r : std_logic := '0';

  type state_type is (
    IDLE, START_PREP, START, SEND_ADDR, ACK_SLAVE, SEND_DATA, ACK_AFTER_SEND,
    RECV_DATA, RECV_ACK_MASTER, STOP_PREP, STOP
  );
  signal state     : state_type := IDLE;

  signal recv_left : integer range 0 to 2 := 0;

begin

  scl <= scl_reg;
  sda <= sda_reg when sda_dir = '1' else 'Z';
  data_rd <= data_rd_r;
  busy    <= busy_r;
  ack_error <= ack_err_r;
  byte_valid <= byte_valid_r;

  combined_proc: process(clk, rst)
    variable clk_cnt_v  : integer := 0;
    variable scl_v      : std_logic := '1';
    variable scl_prev_v : std_logic := '1';
    variable rising_ev  : boolean := false;
    variable falling_ev : boolean := false;
    variable bit_cnt_v  : integer := 7;
    variable shifter_v  : std_logic_vector(7 downto 0) := (others => '0');
  begin
    if rst = '1' then
      clk_cnt_v := 0;
      scl_v := '1';
      scl_prev_v := '1';
      rising_ev := false;
      falling_ev := false;

      scl_reg <= '1';
      sda_reg <= '1';
      sda_dir <= '1';
      scl_enable <= '0';

      busy_r <= '0';
      ack_err_r <= '0';
      data_rd_r <= (others => '0');
      byte_valid_r <= '0';
      recv_left <= 0;

      state <= IDLE;
      bit_cnt_v := 7;
      shifter_v := (others => '0');

    elsif rising_edge(clk) then

      -- SCL 分频逻辑
      if scl_enable = '1' then
        if clk_cnt_v >= HALF_TICKS - 1 then
          clk_cnt_v := 0;
          scl_v := not scl_v;
        else
          clk_cnt_v := clk_cnt_v + 1;
        end if;
      else
        clk_cnt_v := 0;
        scl_v := '1';
      end if;

      -- 边沿检测
      rising_ev  := (scl_prev_v = '0' and scl_v = '1');
      falling_ev := (scl_prev_v = '1' and scl_v = '0');

      scl_reg <= scl_v;
      scl_prev_v := scl_v;

      byte_valid_r <= '0';

      case state is
        when IDLE =>
          busy_r <= '0';
          scl_enable <= '0';
          sda_dir <= '1';
          sda_reg <= '1';
          if ena = '1' then
            busy_r <= '1';
            ack_err_r <= '0';
            shifter_v := addr & rw;
            bit_cnt_v := 7;
            state <= START_PREP;
          end if;

        -- 确保 SCL 和 SDA 都为高，准备 START
        when START_PREP =>
          sda_reg <= '1';
          sda_dir <= '1';
          scl_enable <= '0';  -- SCL 保持高
          if scl_v = '1' then
            state <= START;
          end if;

        -- 生成 START 条件：SCL 高时，SDA 下降
        when START =>
          sda_reg <= '0';  -- SDA 拉低
          sda_dir <= '1';
          -- 等待一段时间后启动 SCL
          if clk_cnt_v >= HALF_TICKS / 2 then
            scl_enable <= '1';
            bit_cnt_v := 7;
            state <= SEND_ADDR;
          else
            clk_cnt_v := clk_cnt_v + 1;
          end if;

        when SEND_ADDR =>
          if falling_ev then
            sda_reg <= shifter_v(bit_cnt_v);
            sda_dir <= '1';
          end if;
          if rising_ev then
            if bit_cnt_v = 0 then
              bit_cnt_v := 7;
              sda_dir <= '0';
              state <= ACK_SLAVE;
            else
              bit_cnt_v := bit_cnt_v - 1;
            end if;
          end if;

        when ACK_SLAVE =>
          sda_dir <= '0';  -- 释放 SDA 以读取 ACK
          if rising_ev then
            if sda = '1' then
              ack_err_r <= '1';
            else
              ack_err_r <= '0';
            end if;
          end if;
          if falling_ev then
            if rw = '0' then
              shifter_v := data_wr;
              bit_cnt_v := 7;
              sda_dir <= '1';
              state <= SEND_DATA;
            else
              recv_left <= 2;
              sda_dir <= '0';
              bit_cnt_v := 7;
              state <= RECV_DATA;
            end if;
          end if;

        when SEND_DATA =>
          if falling_ev then
            sda_reg <= shifter_v(bit_cnt_v);
            sda_dir <= '1';
          end if;
          if rising_ev then
            if bit_cnt_v = 0 then
              bit_cnt_v := 7;
              sda_dir <= '0';
              state <= ACK_AFTER_SEND;
            else
              bit_cnt_v := bit_cnt_v - 1;
            end if;
          end if;

        when ACK_AFTER_SEND =>
          sda_dir <= '0';
          if rising_ev then
            if sda = '1' then
              ack_err_r <= '1';
            else
              ack_err_r <= '0';
            end if;
          end if;
          if falling_ev then
            state <= STOP_PREP;
          end if;

        when RECV_DATA =>
          sda_dir <= '0';
          if rising_ev then
            shifter_v(bit_cnt_v) := sda;
            if bit_cnt_v = 0 then
              data_rd_r <= shifter_v;
              byte_valid_r <= '1';
              bit_cnt_v := 7;
              state <= RECV_ACK_MASTER;
            else
              bit_cnt_v := bit_cnt_v - 1;
            end if;
          end if;

        when RECV_ACK_MASTER =>
          -- 在 SCL 下降沿发送 ACK/NACK
          if falling_ev then
            sda_dir <= '1';
            if recv_left > 1 then
              sda_reg <= '0';  -- ACK
              recv_left <= recv_left - 1;
              bit_cnt_v := 7;
              state <= RECV_DATA;
            else
              sda_reg <= '1';  -- NACK
              state <= STOP_PREP;
            end if;
          end if;

        -- 准备 STOP：先拉低 SDA
        when STOP_PREP =>
          if falling_ev then
            sda_dir <= '1';
            sda_reg <= '0';
            state <= STOP;
          end if;

        -- 生成 STOP 条件：SCL 高时，SDA 上升
        when STOP =>
          if scl_v = '1' then
            sda_reg <= '1';
            scl_enable <= '0';
            busy_r <= '0';
            state <= IDLE;
          end if;

        when others =>
          state <= IDLE;
      end case;
    end if;
  end process combined_proc;

end rtl;